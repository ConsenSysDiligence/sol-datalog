// Compute whether a node with ancestorId is the ancestor of a node with descendantId in the AST.
.decl ancestor(ancestorId: id, descendantId: id)

ancestor(x, y) :- parent(x, y).
ancestor(x, y) :- parent(x, z), ancestor(z, y).

// Compute whether there is a state var VariableDeclaration with a given name and id
.decl stateVar(name: symbol, id: id)
stateVar(name, id) :- VariableDeclaration(id, _, _, _, name, _, 1, _, _, _, _, _, _, _, _, _, _).

// Compute whether there is a function definition with a given name and id
.decl function(name: symbol, id: id)
function(name, id) :- FunctionDefinition(id, _, _, _, name, _, _, _, _, _, _, _, _, _, _).

// Compute whether there is a function definition with a given name and id in a given contract
.decl functionIn(name: symbol, id: FunctionDefinitionId, contractId: id)
functionIn(name, id, contractId) :- FunctionDefinition(id, _, contractId, _, name, _, _, _, _, _, _, _, _, _, _).

// Compute whether there is a contract definition with a given name and id
.decl contract(name: symbol, id: id)
contract(name, id) :- ContractDefinition(id, _, name, _, _, _, _).

/// Specifies that a childContractId inherits from baseContractId (or is the same contract)
.decl inherits(childContractId: ContractDefinitionId, baseContractId: ContractDefinitionId)
inherits(childContractId, baseContractId) :- ContractDefinition(childContractId, _, _, _, _, _, _), childContractId = baseContractId.
inherits(childContractId, baseContractId) :-
    ContractDefinition(childContractId, _, _, _, _, _, _),
    ContractDefinition(baseContractId, _, _, _, _, _, _),
    ContractDefinition_linearizedBaseContracts(childContractId, baseContractId, _).

/// Specifies that a method definition `methodId` belongs to contract `contractId` or one of its bases.
.decl method(contractId: ContractDefinitionId, methodId: FunctionDefinitionId)
method(contractId, methodId) :- inherits(contractId, baseId), functionIn(_ ,methodId, baseId).

