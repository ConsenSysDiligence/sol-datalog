// Compute all pairs of nodes (ancestorId, descendantId) where descendantId is a descendant ot ancestorId in the AST.
.decl ancestor(ancestorId: id, descendantId: id)

ancestor(x, y) :- parent(x, y).
ancestor(x, y) :- parent(x, z), ancestor(z, y).

// Helper to get the name of a state var with a given id
.decl stateVar(name: symbol, id: id)
stateVar(name, id) :- VariableDeclaration(id, _, _, _, name, _, 1, _, _, _, _, _, _, _, _, _, _).

// Helper to get the name of a function with a given id
.decl function(name: symbol, id: id)
function(name, id) :- FunctionDefinition(id, _, _, _, name, _, _, _, _, _, _, _, _, _, _).

// Helper to get the name of a function with a given id in a given contract (contractId)
.decl functionIn(name: symbol, id: FunctionDefinitionId, contractId: id)
functionIn(name, id, contractId) :- FunctionDefinition(id, _, contractId, _, name, _, _, _, _, _, _, _, _, _, _).

// Helper to get the name of a contract with a given id
.decl contract(name: symbol, id: id)
contract(name, id) :- ContractDefinition(id, _, name, _, _, _, _).

/// Specifies that a childContractId inherits from baseContractId (or is the same contract)
.decl inherits(childContractId: ContractDefinitionId, baseContractId: ContractDefinitionId)
inherits(childContractId, baseContractId) :- ContractDefinition(childContractId, _, _, _, _, _, _), childContractId = baseContractId.
inherits(childContractId, baseContractId) :-
    ContractDefinition(childContractId, _, _, _, _, _, _),
    ContractDefinition(baseContractId, _, _, _, _, _, _),
    ContractDefinition_linearizedBaseContracts(childContractId, baseContractId, _).

/// Specifies that a method with `methodId` belongs to contract `contractId` or one of its bases.
.decl method(contractId: ContractDefinitionId, methodId: FunctionDefinitionId)
method(contractId, methodId) :- inherits(contractId, baseId), functionIn(_ ,methodId, baseId).