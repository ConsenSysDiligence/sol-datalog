.decl callsDirectly(caller: FunctionDefinitionId, callee: id)
callsDirectly(caller, callee) :- 
    FunctionDefinition(caller),
    ancestor(caller, callId),
    FunctionCall(callId),
    FunctionCall_expression(callId, exprId),
    exprRefersTo(exprId, callee),
    FunctionDefinition(callee).

callsDirectly(caller, callee) :- 
    FunctionDefinition(caller),
    ancestor(caller, callId),
    FunctionCall(callId),
    FunctionCall_expression(callId, exprId),
    exprRefersTo(exprId, calleeBaseDef),
    FunctionDefinition(calleeBaseDef),
    FunctionDefinition_virtual(calleeBaseDef, 1),
    overrides(callee, calleeBaseDef).

.type CallPath = [ head: FunctionDefinitionId, tail: CallPath ]
.functor isSubsequence(a: CallPath, b: CallPath):number stateful

.decl callsPath(caller: FunctionDefinitionId, callee: FunctionDefinitionId, path: CallPath)

// Base case - if caller has a function call that refers to callee
callsPath(caller, callee, [caller, [callee, nil]]) :-
    callsDirectly(caller, callee).

// Calls is transitive
callsPath(caller, callee, [caller, p]) :-
    callsDirectly(caller, x),
    callsPath(x, callee, p).

callsPath(x, y, p1) <= callsPath(x, y, p2) :- @isSubsequence(p2, p1) = 1.