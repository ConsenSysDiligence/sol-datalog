/// Specifies whether the function `caller` may call the callee `callee`.
/// `callee` may be either another `FunctionDefinition` or a
/// `VariableDeclaration` (corresponding to a public variable getter)
.decl callsDirectly(caller: FunctionDefinitionId, callee: id)

// Simple call case
callsDirectly(caller, callee) :- 
    FunctionDefinition(caller),
    ancestor(caller, callId),
    FunctionCall(callId),
    FunctionCall_expression(callId, exprId),
    exprRefersTo(exprId, callee),
    FunctionDefinition(callee).

// Calling a virtual function - include all overriding definitions
callsDirectly(caller, callee) :- 
    FunctionDefinition(caller),
    ancestor(caller, callId),
    FunctionCall(callId),
    FunctionCall_expression(callId, exprId),
    exprRefersTo(exprId, calleeBaseDef),
    FunctionDefinition(calleeBaseDef),
    FunctionDefinition_virtual(calleeBaseDef, 1),
    overrides(callee, calleeBaseDef).

// Calling a user-defined binary operator
callsDirectly(caller, callee) :-
    FunctionDefinition(caller),
    ancestor(caller, exprId),
    BinaryOperation_userFunction(exprId, callee, 1).

// Calling a user-defined unary operator
callsDirectly(caller, callee) :-
    FunctionDefinition(caller),
    ancestor(caller, exprId),
    UnaryOperation_userFunction(exprId, callee, 1).

.type CallPath = [ head: FunctionDefinitionId, tail: CallPath ]
.functor isSubsequence(a: CallPath, b: CallPath):number stateful

.decl callsPath(caller: FunctionDefinitionId, callee: FunctionDefinitionId, path: CallPath)

// Base case - if caller has a function call that refers to callee
callsPath(caller, callee, [caller, [callee, nil]]) :-
    callsDirectly(caller, callee).

// Calls is transitive
callsPath(caller, callee, [caller, p]) :-
    callsDirectly(caller, x),
    callsPath(x, callee, p).

callsPath(x, y, p1) <= callsPath(x, y, p2) :- @isSubsequence(p2, p1) = 1.